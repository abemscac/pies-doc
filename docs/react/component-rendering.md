---
sidebar_position: 4
description: Introduce the basics of component rendering in React.
keywords: [piesdoc, react, react component rendering]
---

import Badge from '@site/src/widgets/Badge'
import Video from '@site/src/widgets/Video'

# Component Rendering

This chapter is crucial for understanding how states work in React. If you're not having a good time dealing with states, this chapter might be able to save you.

In this chapter, we don't talk about virtual DOM, nor do we talk about complicated algorithms; instead, we talk about the most relevant things for users (you and me, the developers) — what exactly is rendering and how does it effect our components.

## What Does Render Mean?

In React, "render" means to run the code in your component from top to bottom, and transform the output JSX elements into a DOM node. Any subsequent render after the very first render is called "re-render".

## When Does a Component Re-Render?

A component re-renders when any **reactive value** is updated; reactive values include:

- Values generated by [`useState()`](./use-state).
- Values generated by [`useReducer()`](./use-reducer).
- Props of a component.

Changing anything else other than reactive values will not trigger a re-render.

To change a reactive value, we must use the corresponding function like [`setState()`](./use-state#setstate) or [`dispatch()`](./use-reducer#dispatch). However, changes will **not** be applied immediately after those functions are called. The way those functions work is more like **requesting an update**, instead of doing an instant update.

### When Will Reactive Values Be Updated?

For example, if you try to access a state immediately after `setState()` is called, you'll find that the state is not being updated at all:

```ts showLineNumbers
import { useState } from 'react'

const [count, setCount] = useState(0)

const click = () => {
  console.log('Before: ', count) // Before: 0
  setCount(5)
  // Still 0!
  // highlight-next-line
  console.log('After: ', count) // After: 0
}
```

Good news is, this is not a bug; but it does confuse everyone! For this reason, we'll refer to functions like `setState()` or `dispatch()` as "**update requests**" in this documentation. So, when exactly will states be updated after update requests are sent? A simple rule of thumb would be:

1. When the call stack is empty. In other words, when the execution of the event handler (function) that sends the update requests is done. Let's go back to the previous example:

  ```ts showLineNumbers
  import { useState } from 'react'

  const [count, setCount] = useState(0)

  const click = () => {
    console.log('Before: ', count)
    setCount(5)
    // highlight-next-line
    console.log('After: ', count)
  }
  ```

  In this example, `console.log('After: ', count)` is the last action to be done in `click()`. This means after `console.log('After: ', count)` is completed, the execution of `click()` will be considered as done, and `click()` will be removed from the call stack. React will immediately update the states according to our update requests after that.

2. When the caller of async function resumes execution. In other words, right after `await` has done "awaited". For example:

  ```ts showLineNumbers
  import { useState } from 'react'

  const [count, setCount] = useState(0)

  const click = async () => {
    // highlight-next-line
    setCount(1)
    await somethingAsync()

    // highlight-next-line
    setCount(2)
    await somethingAsync()
  }

  const somethingAsync = () => {
    // Do something asynchronous. For example, calling an API.
    return Promise.resolve(true)
  }
  ```

  In the above example, `count` is going to be updated twice:
  
    1. Right after the first `await somethingAsync()` is done (updated from `0` to `1`).
    2. Right after the second `await somethingAsync()` is done (updated from `1` to `2`).
    
  We can easily prove this with the help of `useEffect()`:

  ```ts showLineNumbers
  import { useEffect } from 'react'

  // highlight-start
  useEffect(() => {
    console.log('count has been updated to ', count)
  }, [count])
  // highlight-end
  ```

  <Video src="/video/react/component-rendering_await-triggers-state-update.mov" />

<details>

  <summary>What's the theory behind this? (advanced knowledge, feel free to skip this!)</summary>

  From the description above, you may have guessed it already — those update requests are actually [**microtasks**](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide). If you find it very confusing, feel free to skip it! You'll do just fine without knowing anything about it!
</details>

However, if you try to access `count` after `await somethingAsync()`, you'll find a very depressing truth — it's still not being changed!

```ts
import { useState, useEffect } from 'react'

const [count, setCount] = useState(0)

useEffect(() => {
  console.log('count has been updated to ', count)
}, [count])

const click = async () => {
  setCount(1)
  await somethingAsync()
  // highlight-next-line
  console.log('Show 1, please', count)

  setCount(2)
  await somethingAsync()
  // highlight-next-line
  console.log('Show 2, please', count)
}

const somethingAsync = () => {
  // Do something asynchronous. For example, calling an API.
  return Promise.resolve(true)
}
```

<Video src="/video/react/component-rendering_states-still-not-changed.mov" />

Why is this happening? Again, it's another thing that isn't a bug, but does confuse everyone! We'll explain more about this [below](#how-does-reactive-value-works). Take a break; learning when do reactive values get updated is already a huge step forward!

:::info Tiny Exercise

Tiny exercise! Consider the following snippet:

- How many times do you think `count` will be updated?
- When will `count` be updated?

```ts showLineNumbers
import { useState } from 'react'

const [count, setCount] = useState(0)

const click = async () => {
  setCount(1)
  await somethingAsync()

  setCount(2)
  await somethingAsync()

  setCount(3)
}

const somethingAsync = () => {
  // Do something asynchronous. For example, calling an API.
  return Promise.resolve(true)
}
```

<details>
  <summary>Show me the answer</summary>

  In this example, `count` is going to be updated three times:

  1. Right after the first `await somethingAsync()` is done (updated from `0` to `1`).
  2. Right after the second `await somethingAsync()` is done (updated from `1` to `2`).
  3. When the execution of `click()` is done (updated from `2` to `3`).

  <Video src="/video/react/component-rendering_update-request-exercise.mov" />
  
</details>

:::

## How Does Reactive Value Works?

TODO

## What Happens When A Component Re-Renders?

### Example

Just like how rendering works, React re-runs the code in a component from top to bottom again; let's use counter app as an example:

```tsx showLineNumbers
import React, { useState } from 'react'

export const Example = () => {
  const [count, setCount] = useState(0)

  let countPlusFive = count + 5

  const increment = () => {
    setCount(count + 1)
  }

  return (
    <div>
      <h1>Count = {count}</h1>
      <h2>Count + 5: {countPlusFive}</h2>
      <button onClick={increment}>Increment</button>
    </div>
  )
}
```

Let's start by reviewing the members of this component:

- Props
  - None
- States
  - `count`
- Local variables
  - `countPlusFive`
    - Dependencies: `count`
- Methods
  - `increment()`
    - Dependencies: `count`

The only state in this component is `count`, and we can update `count` by clicking the "Increment" button.

<Video src="/video/react/component-rendering_counter-app.mov" height="200px" />

#### The First Render

In the first render, React initializes the component according to the following logic:

1. Runs `const [count, setCount] = useState(0)`, so `count` and `setCount()` are available now.
2. Runs `let countPlusFive = count + 5`; since the value of `count` is `0` at the very beginning, `countPlusFive` will evaluate to `5`.
3. Runs `const increment = () => { ... }`; since the value of `count` is `0` at the very beginning, `setCount(count + 1)` will evaluate to `setCount(1)`.
4. Binds all necessary values to the JSX elements in the return section, re-renders all child components, and do the return.

This is why in the very first render, we saw `Count = 5` and `Count + 5 = 5` on the screen.

#### The Second Render (The First Re-Render)

After the "Increment" button is clicked for once, the value of `count` will be updated from `0` to `1`; since `count` is a state, this change will cause the component to re-render. After `count` has been updated, React re-renders the component by re-running every single piece of code in this component from top to bottom:

1. Runs `const [count, setCount] = useState(0)`; however, thanks to how `useState()` works internally, `count` and `setCount()` will **not** be redefined. The value of `count` will change, but `setCount()` will remain the same (it's still the same function/object compared to the previous render).
2. Runs `let countPlusFive = count + 5`; since the value of `count` has become `1` now, `countPlusFive` will evaluate to `6`.
3. Runs `const increment = () => { ... }`; since the value of `count` has become `1` now, `setCount(count + 1)` will evaluate to `setCount(2)`.
4. Binds all necessary values to the JSX elements in the return section, re-renders all child components, and do the return.

As you can see, render and re-render are actually not that different from each other. They both follow the same rule — runs the code in a component from top to bottom. **All members and its definitions remain the same within each render, the only difference is the value of variables**. Please keep in mind that:

- **States and props can be seen as constants in each render**; they only reflect the status of a component in the current render, so **they never change in the same render**.
- Everything that depends on reactive values will only be defined/computed after reactive values are updated.

To better explain these ideas, please take a look at the following snippet:

```ts showLineNumbers
import { useState } from 'react'

const [count, setCount] = useState(0)

const click = () => {
  setCount(count + 1)
  setCount(count + 1)
  setCount(count + 1)
}
```

In the above snippet, the value of `count` will be `1` instead of `3` after `click()` is executed. How come?

At the very beginning, the value of `count` is `0`, which means `setCount(count + 1)` in `click()` will all evaluate to `setCount(0 + 1)`. That means in the first render, the value being passed to the `setCount()` in `click()` is destined to be `0 + 1` rather than a dynamic, uncertain value. Think of it this way: the component first knows the value of `count` is `0`, then it defines `click()` by writing hardcoded `setCount(0 + 1)` three times. Any subsequent re-render will just follow the same rule, with no exception.

## Batching

TODO

## Render Methods

TODO

## Component Rendering In Depth

TODO